/-
Copyright (c) 2024 Calle SÃ¶nne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Calle SÃ¶nne, Joseph Hua, Yiming Xu
-/

import Mathlib.CategoryTheory.Bicategory.LocallyDiscrete
import Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Pseudo
import SEq.Tactic.DepRewrite
import Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete
-- import Mathlib.CategoryTheory.Category.Cat.AsSmall
import Mathlib.CategoryTheory.Elements
import Mathlib.CategoryTheory.Comma.Over.Basic


/-!
# The Grothendieck construction

Given a category `ğ’®` and any pseudofunctor `F` from `ğ’®` to `Cat`, we associate to it a category
`âˆ« F`, equipped with a functor `âˆ« F â¥¤ ğ’®`.

The category `âˆ« F` is defined as follows:
* Objects: pairs `(S, a)` where `S` is an object of the base category and `a` is an object of the
  category `F(S)`.
* Morphisms: morphisms `(R, b) âŸ¶ (S, a)` are defined as pairs `(f, h)` where `f : R âŸ¶ S` is a
  morphism in `ğ’®` and `h : b âŸ¶ F(f)(a)`

The projection functor `âˆ« F â¥¤ ğ’®` is then given by projecting to the first factors, i.e.
* On objects, it sends `(S, a)` to `S`
* On morphisms, it sends `(f, h)` to `f`

## Future work / TODO

1. Once the bicategory of pseudofunctors has been defined, show that this construction forms a
pseudofunctor from `Pseudofunctor (LocallyDiscrete ğ’®) Cat` to `Cat`.
2. One could probably deduce the results in `CategoryTheory.Grothendieck` as a specialization of the
results in this file.

## References
[Vistoli2008] "Notes on Grothendieck Topologies, Fibered Categories and Descent Theory" by
Angelo Vistoli

-/

namespace CategoryTheory.Pseudofunctor

universe w vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ

open Functor Category Opposite Discrete Bicategory StrongTrans

section

variable {B : Type uâ‚} [Bicategory B]
variable (F : Pseudofunctor B Cat) {a b : B}


@[simp] lemma _root_.CategoryTheory.LocallyDiscrete.Iso.hom_inv {C : Type uâ‚} [Category C]
    (X Y : LocallyDiscrete C) (e : X â‰… Y) : e.hom.toLoc â‰« e.inv.toLoc = ğŸ™ _ :=
  LocallyDiscrete.eq_of_hom âŸ¨âŸ¨by simpâŸ©âŸ©

-- Autogenerated by adding @[to_app (attr := reassoc)] to `mapComp_assoc_right_hom`
lemma mapComp_assoc_right_hom_app_assoc {c d : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d)
    (X : â†‘(F.obj a)) {Z : â†‘(F.obj d)} (Î· : (F.map f â‰« F.map g â‰« F.map h).obj X âŸ¶ Z) :
    (F.mapComp f (g â‰« h)).hom.app X â‰« (F.mapComp g h).hom.app ((F.map f).obj X) â‰« Î· =
    (F.mapâ‚‚ (Î±_ f g h).inv).app X â‰« (F.mapComp (f â‰« g) h).hom.app X â‰«
    (F.map h).map ((F.mapComp f g).hom.app X) â‰« (Î±_ (F.map f) (F.map g) (F.map h)).hom.app X â‰« Î· :=
  sorry

-- Autogenerated by adding @[to_app (attr := reassoc)] to `StrongTrans.naturality_comp_inv`
def StrongTrans.naturality_comp_inv_app
    {F G : Pseudofunctor B Cat} (Î± : F âŸ¶ G) {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c) (X : â†‘(F.obj a)) :
    (Î±.naturality (f â‰« g)).inv.app X =
    (G.mapComp f g).hom.app ((Î±.app a).obj X) â‰«
    (Î±_ (Î±.app a) (G.map f) (G.map g)).inv.app X â‰«
    (G.map g).map ((Î±.naturality f).inv.app X) â‰«
    (Î±_ (F.map f) (Î±.app b) (G.map g)).hom.app X â‰«
    (Î±.naturality g).inv.app ((F.map f).obj X) â‰«
    (Î±_ (F.map f) (F.map g) (Î±.app c)).inv.app X â‰« (Î±.app c).map ((F.mapComp f g).inv.app X) :=
  sorry


-- Autogenerated by adding @[to_app (attr := reassoc)] to `StrongTrans.naturality_comp_inv`
def StrongTrans.naturality_comp_inv_app_assoc
    {B : Type*} [Bicategory B]
    {F G : Pseudofunctor B Cat} (Î± : F âŸ¶ G) {a b c : B} (f : a âŸ¶ b) (g : b âŸ¶ c)
    (X : â†‘(F.obj a)) {Z : â†‘(G.obj c)} (h : (F.map (f â‰« g) â‰« Î±.app c).obj X âŸ¶ Z) :
    (Î±.naturality (f â‰« g)).inv.app X â‰« h =
    (G.mapComp f g).hom.app ((Î±.app a).obj X) â‰«
    (Î±_ (Î±.app a) (G.map f) (G.map g)).inv.app X â‰«
    (G.map g).map ((Î±.naturality f).inv.app X) â‰«
    (Î±_ (F.map f) (Î±.app b) (G.map g)).hom.app X â‰«
    (Î±.naturality g).inv.app ((F.map f).obj X) â‰«
    (Î±_ (F.map f) (F.map g) (Î±.app c)).inv.app X â‰« (Î±.app c).map ((F.mapComp f g).inv.app X) â‰« h :=
  sorry
end

lemma _root_.CategoryTheory.Functor.toPseudofunctor'_mapâ‚‚ {C : Type uâ‚} [Category.{vâ‚} C] (F : C â¥¤ Cat)
    {a b : LocallyDiscrete C} {f g : a âŸ¶ b} (Î· : f âŸ¶ g) :
    F.toPseudoFunctor'.mapâ‚‚ Î· = eqToHom (by simp [eq_of_hom Î·]) := by
  simp [toPseudoFunctor', pseudofunctorOfIsLocallyDiscrete]

@[simps]
def _root_.CategoryTheory.NatTrans.toStrongTrans' {C : Type uâ‚} [Category.{vâ‚} C] (F G : C â¥¤ Cat) (Î± : F âŸ¶ G) :
    F.toPseudoFunctor' âŸ¶ G.toPseudoFunctor' where
  app x := Î±.app x.as
  naturality _ := eqToIso (Î±.naturality _)
  naturality_naturality Î· := by simp [Functor.toPseudofunctor'_mapâ‚‚]
  naturality_id _ := by ext; simp [Bicategory.leftUnitor, Bicategory.rightUnitor]
  naturality_comp _ _ := by ext; simp [Bicategory.associator]

/-- An `eqToHom` in the category `Cat` is a functor that acts on maps by casts. -/
theorem _root_.CategoryTheory.Cat.map_eqToHom {C1 C2 : Cat} {x y : C1} (f : x âŸ¶ y) (eq : C1 = C2) :
    (eqToHom eq).map f = (cast (by subst eq; rfl) f) := by
  cases eq
  simp[CategoryStruct.id]

variable {ğ’® : Type uâ‚} [Category.{vâ‚} ğ’®] {F : Pseudofunctor (LocallyDiscrete ğ’®) Cat.{vâ‚‚, uâ‚‚}}

/-- The type of objects in the fibered category associated to a presheaf valued in types. -/
@[ext]
structure Grothendieck (F : Pseudofunctor (LocallyDiscrete ğ’®) Cat.{vâ‚‚, uâ‚‚}) where
  /-- The underlying object in the base category. -/
  base : ğ’®
  /-- The object in the fiber of the base object. -/
  fiber : F.obj âŸ¨baseâŸ©

namespace Grothendieck

/-- Notation for the Grothendieck category associated to a pseudofunctor `F`. -/
scoped prefix:75 "âˆ« " => Grothendieck

/-- A morphism in the Grothendieck construction `âˆ« F` between two points `X Y : âˆ« F` consists of
a morphism in the base category `base : X.base âŸ¶ Y.base` and
a morphism in a fiber `f.fiber : (F.map base).obj X.fiber âŸ¶ Y.fiber`.
-/
structure Hom (X Y : âˆ« F) where
  /-- The morphism between base objects. -/
  base : X.base âŸ¶ Y.base
  /-- The morphism in the fiber over the domain. -/
  fiber : (F.map base.toLoc).obj X.fiber âŸ¶ Y.fiber

@[simps! id_base id_fiber comp_base comp_fiber]
instance categoryStruct : CategoryStruct (âˆ« F) where
  Hom X Y := Hom X Y
  id X := {
    base := ğŸ™ X.base
    fiber := (F.mapId âŸ¨X.baseâŸ©).hom.app X.fiber }
  comp {X _ _} f g := {
    base := f.base â‰« g.base
    fiber := (F.mapComp f.base.toLoc g.base.toLoc).hom.app X.fiber â‰«
      (F.map g.base.toLoc).map f.fiber â‰« g.fiber }

instance (X : âˆ« F) : Inhabited (Hom X X) :=
  âŸ¨ğŸ™ XâŸ©

section

variable {a b : âˆ« F}

@[ext (iff := false)]
lemma Hom.ext (f g : a âŸ¶ b) (hfgâ‚ : f.base = g.base)
    (hfgâ‚‚ : eqToHom (hfgâ‚ â–¸ rfl) â‰« f.fiber = g.fiber) : f = g := by
  cases f; cases g
  dsimp at hfgâ‚ hfgâ‚‚
  rw! [â† hfgâ‚‚, â† hfgâ‚]
  simp

lemma Hom.ext_iff (f g : a âŸ¶ b) :
    f = g â†” âˆƒ (hfg : f.base = g.base), eqToHom (hfg â–¸ rfl) â‰« f.fiber = g.fiber where
  mp hfg := by subst hfg; simp
  mpr := fun âŸ¨hfgâ‚, hfgâ‚‚âŸ© => Hom.ext f g hfgâ‚ hfgâ‚‚

lemma Hom.congr {a b : âˆ« F} {f g : a âŸ¶ b} (h : f = g) :
    f.fiber = eqToHom (h â–¸ rfl) â‰« g.fiber := by
  subst h
  simp

end

/-- The category structure on `âˆ« F`. -/
instance category : Category (âˆ« F) where
  toCategoryStruct := Pseudofunctor.Grothendieck.categoryStruct
  id_comp {a b} f := by
    ext
    Â· simp
    Â· simp [F.mapComp_id_left_hom_app, Strict.leftUnitor_eqToIso, â† Functor.map_comp_assoc]
  comp_id {a b} f := by
    ext
    Â· simp
    Â· simp [F.mapComp_id_right_hom_app, Strict.rightUnitor_eqToIso]
  assoc f g h := by
    ext
    Â· simp
    Â· simp [mapComp_assoc_right_hom_app_assoc, Strict.associator_eqToIso]
      -- rw [F.mapComp_assoc_right_hom_app_assoc] after Mathlib change

variable (F)

/-- The projection `âˆ« F â¥¤ ğ’®` given by projecting both objects and homs to the first
factor. -/
@[simps]
def forget (F : Pseudofunctor (LocallyDiscrete ğ’®) Cat.{vâ‚‚, uâ‚‚}) : âˆ« F â¥¤ ğ’® where
  obj X := X.base
  map f := f.base

section

attribute [local simp]
  Strict.leftUnitor_eqToIso Strict.rightUnitor_eqToIso Strict.associator_eqToIso

variable {F} {G : Pseudofunctor (LocallyDiscrete ğ’®) Cat.{vâ‚‚, uâ‚‚}}
  {H : Pseudofunctor (LocallyDiscrete ğ’®) Cat.{vâ‚‚, uâ‚‚}}

/-- The Grothendieck construction is functorial: a strong natural transformation `Î± : F âŸ¶ G`
induces a functor `Grothendieck.map : âˆ« F â¥¤ âˆ« G`.
-/
@[simps!]
def map (Î± : F âŸ¶ G) : âˆ« F â¥¤ âˆ« G where
  obj a := {
    base := a.base
    fiber := (Î±.app âŸ¨a.baseâŸ©).obj a.fiber }
  map {a b} f := {
    base := f.1
    fiber := (Î±.naturality f.1.toLoc).inv.app a.fiber â‰« (Î±.app âŸ¨b.baseâŸ©).map f.2 }
  map_id a := by
    ext
    Â· dsimp
    Â· simp [StrongTrans.naturality_id_inv_app, â† Functor.map_comp]
  map_comp {a b c} f g := by
    ext
    Â· dsimp
    Â· simp only [categoryStruct_comp_base, Quiver.Hom.comp_toLoc,
        StrongTrans.naturality_comp_inv_app_assoc, â† map_comp]
      have := (Î±.naturality g.base.toLoc).inv.naturality_assoc
      simp only [Cat.comp_map] at this
      simp [this]

@[simp]
lemma map_id_map {x y : âˆ« F} (f : x âŸ¶ y) : (map (ğŸ™ F)).map f = f := by
  ext <;> simp

@[simp]
theorem map_comp_forget (Î± : F âŸ¶ G) : map Î± â‹™ forget G = forget F := rfl

section

variable (F)

/-- The natural isomorphism witnessing the pseudo-unity constraint of `Grothendieck.map`. -/
def mapIdIso : map (ğŸ™ F) â‰… ğŸ­ (âˆ« F) :=
  NatIso.ofComponents (fun _ â†¦ eqToIso (by aesop_cat))

lemma map_id_eq : map (ğŸ™ F) = ğŸ­ (âˆ« F) :=
  Functor.ext_of_iso (mapIdIso F) (fun x â†¦ by simp [map]) (fun x â†¦ by simp [mapIdIso])

end

/-- The natural isomorphism witnessing the pseudo-functoriality of `Grothendieck.map`. -/
def mapCompIso (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) : map (Î± â‰« Î²) â‰… map Î± â‹™ map Î² :=
  NatIso.ofComponents (fun _ â†¦ eqToIso (by aesop_cat)) (fun f â†¦ by
    dsimp
    simp only [comp_id, id_comp]
    ext <;> simp)

lemma map_comp_eq (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) : map (Î± â‰« Î²) = map Î± â‹™ map Î² :=
  Functor.ext_of_iso (mapCompIso Î± Î²) (fun _ â†¦ by simp [map]) (fun _ â†¦ by simp [mapCompIso])

end

section Transport

variable {F} (x : âˆ« F) {c : ğ’®}
/--
If `F : Pseudofunctor (LocallyDiscrete ğ’®) Cat` is a pseudofunctor and `t : c âŸ¶ d` is a morphism in
`C`, then `transport` maps each `c`-based element of `âˆ« F` to a `d`-based element.
-/
@[simps]
def transport (t : x.base âŸ¶ c) : âˆ« F :=
  âŸ¨c, (F.map t.toLoc).obj x.fiberâŸ©

/--
If `F : Pseudofunctor (LocallyDiscrete ğ’®) Cat` is a pseudofunctor and `t : c âŸ¶ d` is a morphism in
`toTransport` is the morphism `x âŸ¶ x.transport t` induced by `t` and the identity on fibers.
-/
@[simps]
def toTransport (t : x.base âŸ¶ c) : x âŸ¶ x.transport t := âŸ¨t, (ğŸ™ _)âŸ©

/--
Construct an isomorphism in a Grothendieck construction from isomorphisms in its base and fiber.
-/
@[simps]
def isoMk {X Y : âˆ« F} (eâ‚ : X.base â‰… Y.base)
    (eâ‚‚ : (F.map eâ‚.hom.toLoc).obj X.fiber â‰… Y.fiber) :
    X â‰… Y where
  hom := âŸ¨eâ‚.hom, eâ‚‚.homâŸ©
  inv :=
    âŸ¨eâ‚.inv, (F.map eâ‚.inv.toLoc).map eâ‚‚.inv â‰«
    (F.mapComp eâ‚.hom.toLoc eâ‚.inv.toLoc).inv.app X.fiber â‰«
    (F.mapâ‚‚ (eqToHom (LocallyDiscrete.eq_of_hom âŸ¨âŸ¨by simpâŸ©âŸ©))).app X.fiber â‰«
    (F.mapId âŸ¨X.baseâŸ©).hom.app X.fiber âŸ©
  hom_inv_id := by ext; all_goals simp
  inv_hom_id := by
    ext
    Â· simp
    Â· simp
      sorry

/--
If `F : Pseudofunctor (LocallyDiscrete ğ’®) Cat`  and `x : âˆ« F`, then every `C`-isomorphism
`Î± : x.base â‰… c` induces an isomorphism between `x` and its transport along `Î±`
-/
@[simps!]
def transportIso (Î± : x.base â‰… c) :
    x.transport Î±.hom â‰… x := (isoMk Î± (Iso.refl _)).symm

end Transport

end Pseudofunctor.Grothendieck

end CategoryTheory

/-!
# The Grothendieck construction

Given a functor `F : C â¥¤ Cat`, the objects of `Grothendieck F`
consist of dependent pairs `(b, f)`, where `b : C` and `f : F.obj c`,
and a morphism `(b, f) âŸ¶ (b', f')` is a pair `Î² : b âŸ¶ b'` in `C`, and
`Ï† : (F.map Î²).obj f âŸ¶ f'`

`Grothendieck.functor` makes the Grothendieck construction into a functor from the functor category
`C â¥¤ Cat` to the over category `Over C` in the category of categories.

Categories such as `PresheafedSpace` are in fact examples of this construction,
and it may be interesting to try to generalize some of the development there.

## Implementation notes

In `CategoryTheory.Bicategory.Grothendieck`,
`Cat` is treated as a strict 2-category and `F` is replaced with a pseudofunctor.
This file specializes this construction to 1-category theory.
The design of this file hides the 2-categorical definitions
so that the user only deals with the underlying 1-categories.

There is also a closely related construction starting with `G : Cáµ’áµ– â¥¤ Cat`,
where morphisms consists again of `Î² : b âŸ¶ b'` and `Ï† : f âŸ¶ (F.map (op Î²)).obj f'`.

## Notable constructions

- `Grothendieck F` is the Grothendieck construction.
- Elements of `Grothendieck F` whose base is `c : C` can be transported along `f : c âŸ¶ d` using
`transport`.
- A natural transformation `Î± : F âŸ¶ G` induces `map Î± : Grothendieck F â¥¤ Grothendieck G`.
- The Grothendieck construction and `map` together form a functor (`functor`) from the functor
category `E â¥¤ Cat` to the over category `Over E`.
- A functor `G : D â¥¤ C` induces `pre F G : Grothendieck (G â‹™ F) â¥¤ Grothendieck F`.

## References

See also `CategoryTheory.Functor.Elements` for the category of elements of functor `F : C â¥¤ Type`.

* https://stacks.math.columbia.edu/tag/02XV
* https://ncatlab.org/nlab/show/Grothendieck+construction

-/


universe w u v uâ‚ vâ‚ uâ‚‚ vâ‚‚

namespace CategoryTheory

namespace Functor

variable {C : Type u} [Category.{v} C]
variable {D : Type uâ‚} [Category.{vâ‚} D]
variable (F : C â¥¤ Cat.{vâ‚‚, uâ‚‚})

/--
The Grothendieck construction (often written as `âˆ« F` in mathematics) for a functor `F : C â¥¤ Cat`
gives a category whose
* objects `X` consist of `X.base : C` and `X.fiber : F.obj base`
* morphisms `f : X âŸ¶ Y` consist of
  `base : X.base âŸ¶ Y.base` and
  `f.fiber : (F.map base).obj X.fiber âŸ¶ Y.fiber`
This is implemented as the Grothendieck construction on `F` viewed as a pseudofunctor.
-/
def Grothendieck := F.toPseudoFunctor'.Grothendieck

/-- Notation for the Grothendieck category associated to a functor `F`. -/
scoped prefix:75 "âˆ« " => Grothendieck

namespace Grothendieck

attribute [local simp] eqToHom_map

variable {F}

def base (p : âˆ« F) : C := Pseudofunctor.Grothendieck.base p

def fiber (p : âˆ« F) : F.obj p.base := Pseudofunctor.Grothendieck.fiber p

def mk (b : C) (f : F.obj b) : âˆ« F where
  base := b
  fiber := f

-- NOTE: do not use `simps` attribute to generate these
-- since we want to use `Functor.Grothendieck.base` rather than `Pseudofunctor.Grothendieck.base`
@[simp] lemma mk_base {b : C} {f : F.obj b} : (mk b f).base = b :=
  rfl

@[simp] lemma mk_fiber {b : C} {f : F.obj b} : (mk b f).fiber = f :=
  rfl

/-- A morphism in the Grothendieck category `F : C â¥¤ Cat` consists of
`base : X.base âŸ¶ Y.base` and `f.fiber : (F.map base).obj X.fiber âŸ¶ Y.fiber`.
-/
def Hom (X Y : âˆ« F) := Pseudofunctor.Grothendieck.Hom X Y

namespace Hom

variable {X Y : âˆ« F} (f g : Hom X Y)

/-- The morphism between base objects. -/
def base : X.base âŸ¶ Y.base := Pseudofunctor.Grothendieck.Hom.base f

/-- The morphism from the pushforward to the source fiber object to the target fiber object. -/
def fiber : (F.map f.base).obj X.fiber âŸ¶ Y.fiber := Pseudofunctor.Grothendieck.Hom.fiber f

def mk (b : X.base âŸ¶ Y.base) (f : (F.map b).obj X.fiber âŸ¶ Y.fiber) : Hom X Y where
  base := b
  fiber := f

@[ext (iff := false)]
theorem ext (w_base : f.base = g.base)
    (w_fiber : eqToHom (by rw [w_base]) â‰« f.fiber = g.fiber) : f = g :=
  Pseudofunctor.Grothendieck.Hom.ext _ _ w_base w_fiber

lemma ext_iff : f = g â†” âˆƒ (hfg : f.base = g.base), eqToHom (hfg â–¸ rfl) â‰« f.fiber = g.fiber :=
  Pseudofunctor.Grothendieck.Hom.ext_iff f g

lemma congr {f g : Hom X Y} (h : f = g) : f.fiber = eqToHom (h â–¸ rfl) â‰« g.fiber :=
  Pseudofunctor.Grothendieck.Hom.congr h

instance (X : âˆ« F) : Inhabited (Hom X X) :=
  inferInstanceAs (Inhabited (Pseudofunctor.Grothendieck.Hom _ _))

def id (X : âˆ« F) : Hom X X := Pseudofunctor.Grothendieck.categoryStruct.id X

def comp {X Y Z : âˆ« F} (f : Hom X Y) (g : Hom Y Z) : Hom X Z :=
  Pseudofunctor.Grothendieck.categoryStruct.comp f g

end Hom

instance : Category (âˆ« F) := {
  (inferInstanceAs $ Category (F.toPseudoFunctor'.Grothendieck)) with
  Hom := Hom
  id := Hom.id
  comp := Hom.comp
  }

namespace Hom

@[simp]
lemma id_base (X : âˆ« F) :
    Hom.base (ğŸ™ X) = ğŸ™ X.base :=
  rfl

@[simp]
lemma id_fiber (X : âˆ« F) :
    Hom.fiber (ğŸ™ X) = eqToHom (by simp) := by
  simp [Hom.fiber, CategoryStruct.id, Hom.id]

@[simp]
lemma comp_base {X Y Z : âˆ« F} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :
    (f â‰« g).base = f.base â‰« g.base :=
  rfl

@[simp]
lemma comp_fiber {X Y Z : âˆ« F} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) :
    Hom.fiber (f â‰« g) = eqToHom (by simp) â‰« (F.map g.base).map f.fiber â‰« g.fiber := by
  simp [Hom.fiber, CategoryStruct.comp, Hom.comp, Hom.base]

end Hom

@[simp]
lemma base_eqToHom {X Y : âˆ« F} (h : X = Y) :
    (eqToHom h).base = eqToHom (by simp [h]) := by
  subst h; rfl

@[simp]
lemma fiber_eqToHom {X Y : âˆ« F} (h : X = Y) :
    (eqToHom h).fiber = eqToHom (by subst h; simp) := by
  subst h; simp

lemma eqToHom_eq_mk {X Y : âˆ« F} (hF : X = Y) :
    eqToHom hF = Hom.mk (eqToHom (by subst hF; rfl)) (eqToHom (by subst hF; simp)) := by
  subst hF
  simp [Hom.mk, CategoryStruct.id, Hom.id, base]

section

variable (F)

/-- The forgetful functor from `âˆ« F` to the source category. -/
def forget : âˆ« F â¥¤ C := Pseudofunctor.Grothendieck.forget _

@[simp] lemma forget_obj (X : âˆ« F) :
    (Pseudofunctor.Grothendieck.forget _).obj X = X.base :=
  Pseudofunctor.Grothendieck.forget_obj _ _

@[simp] lemma forget_map {X Y : âˆ« F} (f : X âŸ¶ Y) :
    (Pseudofunctor.Grothendieck.forget _).map f = f.base :=
  Pseudofunctor.Grothendieck.forget_map _ _

end

section ext

theorem hext {x y : âˆ« F} (hbase : x.base = y.base) (hfiber : HEq x.fiber y.fiber) : x = y := by
  rcases x with âŸ¨xbase, xfiberâŸ©
  subst hbase
  subst hfiber
  rfl

theorem hext_iff {x y : âˆ« F} : x.base = y.base âˆ§ HEq x.fiber y.fiber
    â†” x = y := by
  constructor
  Â· intro âŸ¨ hÎ± , hstr âŸ©
    exact hext hÎ± hstr
  Â· intro hCD
    subst hCD
    exact âŸ¨ rfl , HEq.rfl âŸ©

theorem Hom.hext {X Y : âˆ« F} (f g : Hom X Y) (w_base : f.base = g.base)
    (w_fiber : HEq f.fiber g.fiber) : f = g := by
  cases f; cases g
  congr

variable {F' : C â¥¤ Cat.{vâ‚‚, uâ‚‚}}

theorem hext' (h : F = F') {x : âˆ« F} {y : âˆ« F'}
    (hbase : HEq x.base y.base) (hfiber : HEq x.fiber y.fiber) : HEq x y := by
  rcases x; rcases y
  subst hbase
  congr

theorem Hom.hext' (h : F = F') {X Y : âˆ« F} {X' Y' : âˆ« F'} (hX : HEq X X') (hY : HEq Y Y')
    (f : Hom X Y) (g : Hom X' Y') (w_base : HEq f.base g.base) (w_fiber : HEq f.fiber g.fiber) :
    HEq f g := by
  cases f; cases g
  congr

theorem FunctorTo.hext (G H : D â¥¤ âˆ« F)
    (hbase : G â‹™ forget _ = H â‹™ forget _)
    (hfiber_obj : âˆ€ x : D, HEq (G.obj x).fiber (H.obj x).fiber)
    (hfiber_map : âˆ€ {x y : D} (f : x âŸ¶ y), HEq (G.map f).fiber (H.map f).fiber)
    : G = H := by
  fapply CategoryTheory.Functor.ext
  Â· intro x
    apply Grothendieck.hext
    Â· exact Functor.congr_obj hbase x
    Â· apply hfiber_obj
  Â· intro x y f
    fapply Grothendieck.Hom.hext
    Â· simp only [Hom.comp_base, base_eqToHom]
      exact Functor.congr_hom hbase f
    Â· simp only [Hom.comp_fiber, fiber_eqToHom, eqToHom_map, heq_eqToHom_comp_iff,
        heq_comp_eqToHom_iff]
      rw! [base_eqToHom, eqToHom_map, hfiber_map f, Cat.map_eqToHom]
      simp

end ext
section Transport

/--
If `F : C â¥¤ Cat` is a functor and `t : c âŸ¶ d` is a morphism in `C`, then `transport` maps each
`c`-based element of `âˆ« F` to a `d`-based element.
-/
def transport (x : âˆ« F) {c : C} (t : x.base âŸ¶ c) : âˆ« F :=
  mk c ((F.map t).obj x.fiber)

@[simp]
def transport_base (x : âˆ« F) {c : C} (t : x.base âŸ¶ c) : (transport x t).base = c := by
  rfl

@[simp]
def transport_fiber (x : âˆ« F) {c : C} (t : x.base âŸ¶ c) :
    (transport x t).fiber = (F.map t).obj x.fiber := by
  rfl

/--
If `F : C â¥¤ Cat` is a functor and `t : c âŸ¶ d` is a morphism in `C`, then `transport` maps each
`c`-based element `x` of `âˆ« F` to a `d`-based element `x.transport t`.

`toTransport` is the morphism `x âŸ¶ x.transport t` induced by `t` and the identity on fibers.
-/
def toTransport (x : âˆ« F) {c : C} (t : x.base âŸ¶ c) : x âŸ¶ x.transport t :=
  Hom.mk t (ğŸ™ _)

@[simp]
def toTransport_base (x : âˆ« F) {c : C} (t : x.base âŸ¶ c) : (toTransport x t).base = t := by
  rfl

@[simp]
def toTransport_fiber (x : âˆ« F) {c : C} (t : x.base âŸ¶ c) :
    (toTransport x t).fiber = ğŸ™ _ := by
  rfl

/--
Construct an isomorphism in a Grothendieck construction from isomorphisms in its base and fiber.
-/
def isoMk {X Y : âˆ« F} (eâ‚ : X.base â‰… Y.base)
    (eâ‚‚ : (F.map eâ‚.hom).obj X.fiber â‰… Y.fiber) :
    X â‰… Y :=
  Pseudofunctor.Grothendieck.isoMk eâ‚ eâ‚‚

@[simp]
lemma isoMk_hom_base {X Y : âˆ« F} (eâ‚ : X.base â‰… Y.base)
    (eâ‚‚ : (F.map eâ‚.hom).obj X.fiber â‰… Y.fiber) :
    (isoMk eâ‚ eâ‚‚).hom.base = eâ‚.hom :=
  Pseudofunctor.Grothendieck.isoMk_hom_base eâ‚ eâ‚‚

@[simp]
lemma isoMk_hom_fiber {X Y : âˆ« F} (eâ‚ : X.base â‰… Y.base)
    (eâ‚‚ : (F.map eâ‚.hom).obj X.fiber â‰… Y.fiber) :
    (isoMk eâ‚ eâ‚‚).hom.fiber = eâ‚‚.hom :=
  Pseudofunctor.Grothendieck.isoMk_hom_fiber eâ‚ eâ‚‚

@[simp]
lemma isoMk_inv_base {X Y : âˆ« F} (eâ‚ : X.base â‰… Y.base)
    (eâ‚‚ : (F.map eâ‚.hom).obj X.fiber â‰… Y.fiber) :
    (isoMk eâ‚ eâ‚‚).inv.base = eâ‚.inv :=
  Pseudofunctor.Grothendieck.isoMk_inv_base eâ‚ eâ‚‚

@[simp]
lemma isoMk_inv_fiber {X Y : âˆ« F} (eâ‚ : X.base â‰… Y.base)
    (eâ‚‚ : (F.map eâ‚.hom).obj X.fiber â‰… Y.fiber) :
    (isoMk eâ‚ eâ‚‚).inv.fiber = (F.map eâ‚.inv).map eâ‚‚.inv â‰« eqToHom (by
      simp [â† Functor.comp_obj, â† Cat.comp_eq_comp, â† Functor.map_comp]) := by
  simp [Grothendieck.isoMk, Hom.fiber]

/--
If `F : C â¥¤ Cat` and `x : âˆ« F`, then every `C`-isomorphism `Î± : x.base â‰… c` induces
an isomorphism between `x` and its transport along `Î±`
-/
def transportIso (x : âˆ« F) {c : C} (Î± : x.base â‰… c) :
    x.transport Î±.hom â‰… x := (isoMk Î± (Iso.refl _)).symm

lemma transportIso_hom_base (x : âˆ« F) {c : C} (Î± : x.base â‰… c) :
    (x.transportIso Î±).hom.base = Î±.inv :=
  Pseudofunctor.Grothendieck.transportIso_hom_base _ _

lemma transportIso_hom_fiber (x : âˆ« F) {c : C} (Î± : x.base â‰… c) :
    (x.transportIso Î±).hom.fiber =
    eqToHom (by simp [transportIso, â† Functor.comp_obj, â† Cat.comp_eq_comp]) := by
  simp only [transportIso, Iso.symm_hom, isoMk_inv_fiber, Iso.refl_inv]
  erw [Functor.map_id]
  simp

lemma transportIso_inv_base (x : âˆ« F) {c : C} (Î± : x.base â‰… c) :
    (x.transportIso Î±).inv.base = Î±.hom :=
  Pseudofunctor.Grothendieck.transportIso_inv_base _ _

lemma transportIso_inv_fiber (x : âˆ« F) {c : C} (Î± : x.base â‰… c) :
    (x.transportIso Î±).inv.fiber = ğŸ™ ((F.map Î±.hom).obj x.fiber) :=
  Pseudofunctor.Grothendieck.transportIso_inv_fiber _ _

end Transport

section

variable {G H : C â¥¤ Cat.{vâ‚‚,uâ‚‚}}

/-- The Grothendieck construction is functorial: a natural transformation `Î± : F âŸ¶ G` induces
a functor `Grothendieck.map : âˆ« F â¥¤ âˆ« G`.
Note the more general version `Pseudofunctor.Grothendieck.map` can produce such a functor
`âˆ« F â¥¤ âˆ« G` while only requiring `Î±` to be a strong transformation between `F` and `G`
as pseudofunctors.
-/
def map (Î± : F âŸ¶ G) : âˆ« F â¥¤ âˆ« G :=
  Pseudofunctor.Grothendieck.map Î±.toStrongTrans'

variable {Î± : F âŸ¶ G}

@[simp]
lemma map_obj_base (a : âˆ« F) :
    ((map Î±).obj a).base = a.base :=
  rfl

@[simp]
lemma map_obj_fiber (a : âˆ« F) :
    ((map Î±).obj a).fiber = (Î±.app a.base).obj a.fiber :=
  rfl

@[simp]
lemma map_map_base {a b : âˆ« F} (f : a âŸ¶ b) :
    ((map Î±).map f).base = f.base :=
  rfl

@[simp]
lemma map_map_fiber {a b : âˆ« F} (f : a âŸ¶ b) :
    ((map Î±).map f).fiber = eqToHom (Functor.congr_obj (Î±.naturality f.base).symm a.fiber) â‰«
    (Î±.app b.base).map f.fiber := by
  dsimp only [map, Hom.fiber]
  aesop_cat

/-- The functor `Grothendieck.map Î± : âˆ« F â¥¤ âˆ« G` lies over `C`. -/
@[simp]
theorem map_comp_forget {Î± : F âŸ¶ G} :
    Grothendieck.map Î± â‹™ Grothendieck.forget G = Grothendieck.forget F := rfl

theorem map_id_eq : map (ğŸ™ F) = ğŸ™ (Cat.of <| Grothendieck <| F) := by
  apply FunctorTo.hext
  all_goals simp [Cat.id_eq_id, Functor.id_comp]

/-- Making the equality of functors into an isomorphism. Note: we should avoid equality of functors
if possible, and we should prefer `mapIdIso` to `map_id_eq` whenever we can. -/
def mapIdIso : map (ğŸ™ F) â‰… ğŸ™ (Cat.of <| Grothendieck <| F) := eqToIso map_id_eq

theorem map_comp_eq (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) :
    map (Î± â‰« Î²) = map Î± â‹™ map Î² := by
  apply FunctorTo.hext
  all_goals simp [Functor.assoc]

/-- Making the equality of functors into an isomorphism. Note: we should avoid equality of functors
if possible, and we should prefer `map_comp_iso` to `map_comp_eq` whenever we can. -/
def mapCompIso (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) : map (Î± â‰« Î²) â‰… map Î± â‹™ map Î² := eqToIso (map_comp_eq Î± Î²)

end

/-- The Grothendieck construction as a functor from the functor category `E â¥¤ Cat` to the
over category `Over E`. -/
def functor {E : Cat.{v, u}} : (E â¥¤ Cat.{v,u}) â¥¤ Over (T := Cat.{v,u}) E where
  obj F := Over.mk (X := E) (Y := Cat.of (âˆ« F)) (Grothendieck.forget F)
  map {_ _} Î± := Over.homMk (X:= E) (Grothendieck.map Î±) Grothendieck.map_comp_forget
  map_id F := by
    ext
    exact Grothendieck.map_id_eq (F := F)
  map_comp Î± Î² := by
    simp [Grothendieck.map_comp_eq Î± Î²]
    rfl

variable (G : C â¥¤ Type w)

/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/
@[simps!]
def grothendieckTypeToCatFunctor : âˆ«(G â‹™ typeToCat) â¥¤ G.Elements where
  obj X := âŸ¨X.1, X.2.asâŸ©
  map f := âŸ¨f.1, f.2.1.1âŸ©

/-- Auxiliary definition for `grothendieckTypeToCat`, to speed up elaboration. -/
@[simps!]
def grothendieckTypeToCatInverse : G.Elements â¥¤ âˆ«(G â‹™ typeToCat) where
  obj X := âŸ¨X.1, âŸ¨X.2âŸ©âŸ©
  map f := âŸ¨f.1, âŸ¨âŸ¨f.2âŸ©âŸ©âŸ©

/-- The Grothendieck construction applied to a functor to `Type`
(thought of as a functor to `Cat` by realising a type as a discrete category)
is the same as the 'category of elements' construction.
-/
@[simps!]
def grothendieckTypeToCat : âˆ«(G â‹™ typeToCat) â‰Œ G.Elements where
  functor := grothendieckTypeToCatFunctor G
  inverse := grothendieckTypeToCatInverse G
  unitIso :=
    NatIso.ofComponents
      (fun X => by
        rcases X with âŸ¨_, âŸ¨âŸ©âŸ©
        exact Iso.refl _)
      (by
        rintro âŸ¨_, âŸ¨âŸ©âŸ© âŸ¨_, âŸ¨âŸ©âŸ© âŸ¨base, âŸ¨âŸ¨fâŸ©âŸ©âŸ©
        dsimp at *
        simp
        rfl)
  counitIso :=
    NatIso.ofComponents
      (fun X => by
        cases X
        exact Iso.refl _)
      (by
        rintro âŸ¨âŸ© âŸ¨âŸ© âŸ¨f, eâŸ©
        dsimp at *
        simp
        rfl)
  functor_unitIso_comp := by
    rintro âŸ¨_, âŸ¨âŸ©âŸ©
    simp
    rfl

end Grothendieck

end Functor

end CategoryTheory
#exit



section Pre

variable (F)

/-- Applying a functor `G : D â¥¤ C` to the base of the Grothendieck construction induces a functor
`âˆ«(G â‹™ F) â¥¤ âˆ« F`. -/
@[simps]
def pre (G : D â¥¤ C) : âˆ«(G â‹™ F) â¥¤ âˆ« F where
  obj X := âŸ¨G.obj X.base, X.fiberâŸ©
  map f := âŸ¨G.map f.base, f.fiberâŸ©
  map_id X := Grothendieck.ext _ _ (G.map_id _) (by simp)
  map_comp f g := Grothendieck.ext _ _ (G.map_comp _ _) (by simp)

@[simp]
theorem pre_id : pre F (ğŸ­ C) = ğŸ­ _ := rfl

/--
An natural isomorphism between functors `G â‰… H` induces a natural isomorphism between the canonical
morphism `pre F G` and `pre F H`, up to composition with
`âˆ«(G â‹™ F) â¥¤ âˆ«(H â‹™ F)`.
-/
def preNatIso {G H : D â¥¤ C} (Î± : G â‰… H) :
    pre F G â‰… map (whiskerRight Î±.hom F) â‹™ (pre F H) :=
  NatIso.ofComponents
    (fun X => (transportIso âŸ¨G.obj X.base, X.fiberâŸ© (Î±.app X.base)).symm)
    (fun f => by fapply Grothendieck.ext <;> simp)

/--
Given an equivalence of categories `G`, `preInv _ G` is the (weak) inverse of the `pre _ G.functor`.
-/
def preInv (G : D â‰Œ C) : âˆ« F â¥¤ âˆ«(G.functor â‹™ F) :=
  map (whiskerRight G.counitInv F) â‹™ Grothendieck.pre (G.functor â‹™ F) G.inverse

variable {F} in
lemma pre_comp_map (G : D â¥¤ C) {H : C â¥¤ Cat} (Î± : F âŸ¶ H) :
    pre F G â‹™ map Î± = map (whiskerLeft G Î±) â‹™ pre H G := rfl

variable {F} in
lemma pre_comp_map_assoc (G : D â¥¤ C) {H : C â¥¤ Cat} (Î± : F âŸ¶ H) {E : Type*} [Category E]
    (K : âˆ« H â¥¤ E) : pre F G â‹™ map Î± â‹™ K= map (whiskerLeft G Î±) â‹™ pre H G â‹™ K := rfl

variable {E : Type*} [Category E] in
@[simp]
lemma pre_comp (G : D â¥¤ C) (H : E â¥¤ D) : pre F (H â‹™ G) = pre (G â‹™ F) H â‹™ pre F G := rfl

/--
Let `G` be an equivalence of categories. The functor induced via `pre` by `G.functor â‹™ G.inverse`
is naturally isomorphic to the functor induced via `map` by a whiskered version of `G`'s inverse
unit.
-/
protected def preUnitIso (G : D â‰Œ C) :
    map (whiskerRight G.unitInv _) â‰… pre (G.functor â‹™ F) (G.functor â‹™ G.inverse) :=
  preNatIso _ G.unitIso.symm |>.symm

/--
Given a functor `F : C â¥¤ Cat` and an equivalence of categories `G : D â‰Œ C`, the functor
`pre F G.functor` is an equivalence between `âˆ« (G.functor â‹™ F)` and `âˆ« F`.
-/
def preEquivalence (G : D â‰Œ C) : âˆ« (G.functor â‹™ F) â‰Œ âˆ« F where
  functor := pre F G.functor
  inverse := preInv F G
  unitIso := by
    refine (eqToIso ?_)
      â‰ªâ‰« (Grothendieck.preUnitIso F G |> isoWhiskerLeft (map _))
      â‰ªâ‰« (pre_comp_map_assoc G.functor _ _ |> Eq.symm |> eqToIso)
    calc
      _ = map (ğŸ™ _) := map_id_eq.symm
      _ = map _ := ?_
      _ = map _ â‹™ map _ := map_comp_eq _ _
    congr; ext X
    simp only [Functor.comp_obj, Functor.comp_map, â† Functor.map_comp, Functor.id_obj,
      Functor.map_id, NatTrans.comp_app, NatTrans.id_app, whiskerLeft_app, whiskerRight_app,
      Equivalence.counitInv_functor_comp]
  counitIso := preNatIso F G.counitIso.symm |>.symm
  functor_unitIso_comp := by
    intro X
    simp only [preInv, Grothendieck.preUnitIso, pre_id,
      Iso.trans_hom, eqToIso.hom, eqToHom_app, eqToHom_refl, isoWhiskerLeft_hom, NatTrans.comp_app]
    fapply Grothendieck.ext <;> simp [preNatIso, transportIso]

variable {F} in
/--
Let `F, F' : C â¥¤ Cat` be functor, `G : D â‰Œ C` an equivalence and `Î± : F âŸ¶ F'` a natural
transformation.

Left-whiskering `Î±` by `G` and then taking the Grothendieck construction is, up to isomorphism,
the same as taking the Grothendieck construction of `Î±` and using the equivalences `pre F G`
and `pre F' G` to match the expected type:

```
âˆ«(G.functor â‹™ F) â‰Œ âˆ« F â¥¤ âˆ« F' â‰Œ âˆ«(G.functor â‹™ F')
```
-/
def mapWhiskerLeftIsoConjPreMap {F' : C â¥¤ Cat} (G : D â‰Œ C) (Î± : F âŸ¶ F') :
    map (whiskerLeft G.functor Î±) â‰…
      (preEquivalence F G).functor â‹™ map Î± â‹™ (preEquivalence F' G).inverse :=
  (Functor.rightUnitor _).symm â‰ªâ‰« isoWhiskerLeft _ (preEquivalence F' G).unitIso

end Pre

section FunctorFrom

variable {E : Type*} [Category E]

variable (F) in
/-- The inclusion of a fiber `F.obj c` of a functor `F : C â¥¤ Cat` into its Grothendieck
construction. -/
@[simps obj map]
def Î¹ (c : C) : F.obj c â¥¤ âˆ« F where
  obj d := âŸ¨c, dâŸ©
  map f := âŸ¨ğŸ™ _, eqToHom (by simp) â‰« fâŸ©
  map_id d := by
    dsimp
    congr
    simp only [Category.comp_id]
  map_comp f g := by
    apply Grothendieck.ext _ _ (by simp)
    simp only [comp_base, â† Category.assoc, eqToHom_trans, comp_fiber, Functor.map_comp,
      eqToHom_map]
    congr 1
    simp only [eqToHom_comp_iff, Category.assoc, eqToHom_trans_assoc]
    apply Functor.congr_hom (F.map_id _).symm

instance faithful_Î¹ (c : C) : (Î¹ F c).Faithful where
  map_injective f := by
    injection f with _ f
    rwa [cancel_epi] at f

/-- Every morphism `f : X âŸ¶ Y` in the base category induces a natural transformation from the fiber
inclusion `Î¹ F X` to the composition `F.map f â‹™ Î¹ F Y`. -/
@[simps]
def Î¹NatTrans {X Y : C} (f : X âŸ¶ Y) : Î¹ F X âŸ¶ F.map f â‹™ Î¹ F Y where
  app d := âŸ¨f, ğŸ™ _âŸ©
  naturality _ _ _ := by
    simp only [Î¹, Functor.comp_obj, Functor.comp_map]
    exact Grothendieck.ext _ _ (by simp) (by simp [eqToHom_map])

variable (fib : âˆ€ c, F.obj c â¥¤ E) (hom : âˆ€ {c c' : C} (f : c âŸ¶ c'), fib c âŸ¶ F.map f â‹™ fib c')
variable (hom_id : âˆ€ c, hom (ğŸ™ c) = eqToHom (by simp only [Functor.map_id]; rfl))
variable (hom_comp : âˆ€ câ‚ câ‚‚ câ‚ƒ (f : câ‚ âŸ¶ câ‚‚) (g : câ‚‚ âŸ¶ câ‚ƒ), hom (f â‰« g) =
  hom f â‰« whiskerLeft (F.map f) (hom g) â‰« eqToHom (by simp only [Functor.map_comp]; rfl))

/-- Construct a functor from `âˆ« F` to another category `E` by providing a family of
functors on the fibers of `âˆ« F`, a family of natural transformations on morphisms in the
base of `âˆ« F` and coherence data for this family of natural transformations. -/
@[simps]
def functorFrom : âˆ« F â¥¤ E where
  obj X := (fib X.base).obj X.fiber
  map {X Y} f := (hom f.base).app X.fiber â‰« (fib Y.base).map f.fiber
  map_id X := by simp [hom_id]
  map_comp f g := by simp [hom_comp]

/-- `Grothendieck.Î¹ F c` composed with `Grothendieck.functorFrom` is isomorphic a functor on a fiber
on `F` supplied as the first argument to `Grothendieck.functorFrom`. -/
def Î¹CompFunctorFrom (c : C) : Î¹ F c â‹™ (functorFrom fib hom hom_id hom_comp) â‰… fib c :=
  NatIso.ofComponents (fun _ => Iso.refl _) (fun f => by simp [hom_id])

end FunctorFrom

/-- The fiber inclusion `Î¹ F c` composed with `map Î±` is isomorphic to `Î±.app c â‹™ Î¹ F' c`. -/
@[simps!]
def Î¹CompMap {F' : C â¥¤ Cat} (Î± : F âŸ¶ F') (c : C) : Î¹ F c â‹™ map Î± â‰… Î±.app c â‹™ Î¹ F' c :=
  NatIso.ofComponents (fun X => Iso.refl _) (fun f => by simp [map])

end Grothendieck

end CategoryTheory

section AsSmall
variable (F)

/-- The inverse functor to build the equivalence `compAsSmallFunctorEquivalence`. -/
@[simps]
def compAsSmallFunctorEquivalenceInverse :
    âˆ« F â¥¤ âˆ«(F â‹™ Cat.asSmallFunctor.{w}) where
  obj X := âŸ¨X.base, AsSmall.up.obj X.fiberâŸ©
  map f := âŸ¨f.base, AsSmall.up.map f.fiberâŸ©

/-- The functor to build the equivalence `compAsSmallFunctorEquivalence`. -/
@[simps]
def compAsSmallFunctorEquivalenceFunctor :
    âˆ«(F â‹™ Cat.asSmallFunctor.{w}) â¥¤ âˆ« F where
  obj X := âŸ¨X.base, AsSmall.down.obj X.fiberâŸ©
  map f := âŸ¨f.base, AsSmall.down.map f.fiberâŸ©
  map_id _ := by apply Grothendieck.ext <;> simp
  map_comp _ _ := by apply Grothendieck.ext <;> simp [down_comp]

/-- Taking the Grothendieck construction on `F â‹™ asSmallFunctor`, where
`asSmallFunctor : Cat â¥¤ Cat` is the functor which turns each category into a small category of a
(potentiall) larger universe, is equivalent to the Grothendieck construction on `F` itself. -/
@[simps]
def compAsSmallFunctorEquivalence :
    Grothendieck (F â‹™ Cat.asSmallFunctor.{w}) â‰Œ âˆ« F where
  functor := compAsSmallFunctorEquivalenceFunctor F
  inverse := compAsSmallFunctorEquivalenceInverse F
  counitIso := Iso.refl _
  unitIso := Iso.refl _

variable {F} in
/-- Mapping a Grothendieck construction along the whiskering of any natural transformation
`Î± : F âŸ¶ G` with the functor `asSmallFunctor : Cat â¥¤ Cat` is naturally isomorphic to conjugating
`map Î±` with the equivalence between `Grothendieck (F â‹™ asSmallFunctor)` and `âˆ« F`. -/
def mapWhiskerRightAsSmallFunctor (Î± : F âŸ¶ G) :
    map (whiskerRight Î± Cat.asSmallFunctor.{w}) â‰…
    (compAsSmallFunctorEquivalence F).functor â‹™ map Î± â‹™
      (compAsSmallFunctorEquivalence G).inverse :=
  NatIso.ofComponents
    (fun X => Iso.refl _)
    (fun f => by
      fapply Grothendieck.ext
      Â· simp [compAsSmallFunctorEquivalenceInverse]
      Â· simp only [compAsSmallFunctorEquivalence_functor, compAsSmallFunctorEquivalence_inverse,
          Functor.comp_obj, compAsSmallFunctorEquivalenceInverse_obj_base, map_obj_base,
          compAsSmallFunctorEquivalenceFunctor_obj_base, Cat.asSmallFunctor_obj, Cat.of_Î±,
          Iso.refl_hom, Functor.comp_map, comp_base, id_base,
          compAsSmallFunctorEquivalenceInverse_map_base, map_map_base,
          compAsSmallFunctorEquivalenceFunctor_map_base, Cat.asSmallFunctor_map, map_obj_fiber,
          whiskerRight_app, AsSmall.down_obj, AsSmall.up_obj_down,
          compAsSmallFunctorEquivalenceInverse_obj_fiber,
          compAsSmallFunctorEquivalenceFunctor_obj_fiber, comp_fiber, map_map_fiber,
          AsSmall.down_map, down_comp, eqToHom_down, AsSmall.up_map_down, Functor.map_comp,
          eqToHom_map, id_fiber, Category.assoc, eqToHom_trans_assoc,
          compAsSmallFunctorEquivalenceInverse_map_fiber,
          compAsSmallFunctorEquivalenceFunctor_map_fiber, eqToHom_comp_iff, comp_eqToHom_iff]
        simp only [conj_eqToHom_iff_heq']
        rw [G.map_id]
        simp )

end AsSmall
